// -*- mode: idl -*-
//A sketch of data structures and APIs.

typedef string ntiid;
typedef string oid_t;

struct Link {
	// A link represents a relationship between two entities.
	// One entity is defined by being the container of the link.
	// The other entity is specified as the target.

	// The target of the link is specified in the href field. This
	// may be a relative URI or an absolute URI. If an absolute
	// URI, it may be an NTIID or some other protocol (such as HTTP).
	string href;
	enum {
		self, // The link is another way of reaching the containing entity
		related, // The target is related to the containing entity
		enclosure, // The target is potentially large data logically contained within this entity
		alternate,
		edit,
	} rel;  //Relationship, represented as a string


	optional string type; // The MIME type of the target.
	optional string title; // The human-readable name of the target.
	optional string ntiid; // The NTIID of the target
}

// TODO: Many of the object properties can be remodeled as
// link relationships. Examples include following, Communities,
// a Theadable's references, etc.


struct Object {
	// The OID is a persistent identifier for a given object. It will always
	// refer to the same object. Its scope is across all users within a particular
	// environment.
	readonly oid_t OID;
	readonly string Creator;
	readonly time_t LastModified;
	readonly time_t CreatedTime;
	readonly string Class; // deprecated
	readonly string MimeType;

	// Any object may optionally have links to other
	// objects, expressing a relationship between them.
	// TODO: should this be inline on the object or part
	// of external metadata? That gets to: do we need a
	// 'entry' wrapper object?
	readonly optional Link[] Links;
}

struct Entity : Object {
	readonly string Username; //The name is always in email format.
	URL avatarUrl;
	string realname;
	string alias;
}

mixin Contained {
	string ContainerId;
}

struct FriendsList : Entity<Contained> {
	Entity friends[]; //'friends' is a list of friends, possibly containing existing users or other emails.
}

struct Person : Entity {
	time_t lastLoginTime; //time_t format, you must set
	out integer NotificationCount; //reset with lastLoginTime

	string Presence; // "Online" or "Offline"

	in string password;

	//list of names of people we are not accepting
	//shared data from
	string ignoring[];
	//List of names of people we agree to accept shared
	//data from. Anytime someone adds us to a friends list,
	//we start accepting data from them (unless we have
	//previously ignored them). This generates a notification and
	//stream event.
	string accepting[];

	//NOTE: ignoring and accepting can be posted to with a single
	//string to add the user to the list (and ensure it's not in the counterpart list).
	//They can also accept a dictionary with up to two keys, add and remove. The values for
	//those keys are lists, and each element of that list will be added or removed
	//as specified


	//Communities I am a member of. I will see all data shared
	//with the community if I follow the community. I will
	//see data shared with people I follow if they share it with the
	//community.
	readonly string[] Communities;

	//The names of individuals or communities I am following.
	//I will see data these people share publically or
	//to a community I belong to. When I add someone to a friends
	//list, I automatically follow them.
	string following[];

	string email[]; //preferred order
	//name is logon name is email
	string organization;
	string role[];
}

struct Preferences : Object {
	//TODO
}

mixin Shareable {
	Entity sharedWith[]; //May be OIDs instead
	//TODO Flags
	bool prohibitReSharing;
}

mixin Anchored<Contained> {
	optional point_t coordinates;
	//and/or
	optional anchor_t anchor;
}

struct Bookmark : Object<Contained,Shareable> { }

struct Highlight : Bookmark {
	range_t ranges[];
}

mixin Threadable {
	oid_t inReplyTo;
	oid_t references[];
}

struct Note : Highlight <Threadable, Anchored> {
	string text; //deprecated
	//An ordered list of objects (strings or objects) that make up the body.
	//In particular, Canvas objects can appear here.
	//text is a synonym for the first body part. Setting text
	//replaces all other bodyParts.
	Object[] body;
}


struct Change : Object<Contained> {
	enum {
		CREATED,
		MODIFIED,
		CIRCLED
	} changeType;
	Object object;
}

struct ActivityStream : Object<Contained> {
	Change changes[];
	//TODO: If we support older/multiple ranges,
	//some indication here of which part of range,
	//whether there is more?
}

//TODO: Library

//API

//The prefix shall include the username: (1) This may help with
//impersonation later; (2) Explicit is better than implicit.
//Thus prefix becomes: /users/$username

/**
 * CRUD
 All creation shall be done by POSTing directly to the prefix.
 The POSTed data MUST have 'ContainerId' and 'Class' attributes.
 Note 1: The root /Objects/ prefix also works.
 Note 2: The returned value shall include the HTTP Location header
 giving the canonical permanent URL of the new data. The canonical
 URLs will change between releases; always respect what the server provides.
 Note 3: In the very near future the Content-Type header will
 be required on the uploaded data. The Content-Type header on the
 response will change.
 This includes quizzes.

 Ediing/updating is done by PUTting modified data to one of:
 1. The canonical URL.
 2. /prefix/Objects/$OID
 3. /Objects/$OID
 Note 1: Very soon the Content-Type will be required.
 Note 2: Locations will soon become embedded in the data.
 Note 3: It is not possible to use PUT to create a new resource.
 Note 4: The same URLs work for DELETE.

 In general, always PUT/POST the entire contents of the object.
 As a special case, to simply change the sharing settings for something,
 one only needs to PUT the dictionary having only
 the 'sharedWith' value to the object's URL.

 Deprecation WARNING:
  The older per-class URLs beneath /prefix/, e.g., /prefix/Notes/,
  should be considered deprecated for fetching since they have terrible
  performance characteristics. Note that these deprecated
  URLs have removed one level of wrapping compared to earlier DS versions.
  These URLs are also deprecated for writing.

  The new URLs are currently rooted at /dataserver2/, while the old, deprecated
  URLs are rooted at /dataserver/.
*/

/**
 * Content-Type
 The value of the content-type header signifies the format
 of the representation in the body of a request or response.
 Our use of content-type (and Accept) is similar to github's
 (http://developer.github.com/v3/mime/). In particular, our format is:

 application/vnd.nextthought[.version][.class][.param][+json|plist]

 If version is missing, it means the latest. Class is required
 for create and update operations (unless specified in the data itself;
 the mime type overrides the data); it is ignored in the Accept header. The class
 is the lowercased version of the 'Class' value from the data.

 No versions are currently defined. No parameters are currently defined.
 JSON is the default but may be specified with +json.

 Also valid in Accept headers are:
 application/json (for the default, latest JSON encoding)
 application/xml  (for the default, latest XML encoding in PList schema)

 Therefore, application/json is equivalent to application/vnd.nextthought+json
 and application/xml is equivalent to application/vnd.nextthought+plist.

 */



/**
 * Supporting finding other entities: GET beneath
     /UserSearch/$searchString => [usernames]
 * $searchString can be empty. It does substring matching
 */

/**
 * Access contained entities (owned and shared): CRUD beneath:
/prefix/Pages/$ntiid/UserGeneratedData/
/prefix/Pages/$ntiid/RecursiveUserGeneratedData/


 * Stream:
/prefix/Pages/$ntiid/Stream/
/prefix/Pages/$ntiid/RecursiveStream/

 * Stream and Data:
/prefix/Pages/$ntiid/UserGeneratedDataAndRecursiveStream
   This URL has the best performance characteristics for most uses. Prefer it.

 * The Recursive versions include the given $ntiid plus
 * all of the $ntiid's children.
 *
 */
